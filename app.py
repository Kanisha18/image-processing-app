# -*- coding: utf-8 -*-
"""image_processing_app.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1g4TUABMlIR7rP_IqU1XJUshmpsVl1q6F
"""

pip install streamlit opencv-python numpy

import streamlit as st
import cv2
import numpy as np
from PIL import Image
import io

st.set_page_config(page_title="Image Processing App", layout="centered")

st.title("üñºÔ∏è Image Processing and Pattern Analysis App")
st.write("Apply filters and image operations interactively using Streamlit!")

uploaded_file = st.file_uploader("Upload an image", type=["jpg", "jpeg", "png"])

if uploaded_file is not None:
    file_bytes = np.asarray(bytearray(uploaded_file.read()), dtype=np.uint8)
    image = cv2.imdecode(file_bytes, 1)
    image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
    st.image(image_rgb, caption="Original Image", use_column_width=True)

    operation = st.selectbox("Choose an Operation", [
        "Grayscale",
        "Gaussian Blur",
        "Canny Edge Detection",
        "Binary Thresholding",
        "Adaptive Thresholding",
        "Erosion",
        "Dilation",
        "Histogram Equalization"
    ])

    processed_image = None

    if operation == "Grayscale":
        processed_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    elif operation == "Gaussian Blur":
        k = st.slider("Kernel Size", 1, 15, 3, step=2)
        processed_image = cv2.GaussianBlur(image, (k, k), 0)

    elif operation == "Canny Edge Detection":
        t1 = st.slider("Threshold1", 0, 255, 100)
        t2 = st.slider("Threshold2", 0, 255, 200)
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        processed_image = cv2.Canny(gray, t1, t2)

    elif operation == "Binary Thresholding":
        threshold = st.slider("Threshold value", 0, 255, 127)
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        _, processed_image = cv2.threshold(gray, threshold, 255, cv2.THRESH_BINARY)

    elif operation == "Adaptive Thresholding":
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        processed_image = cv2.adaptiveThreshold(
            gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 11, 2)

    elif operation == "Erosion":
        ksize = st.slider("Kernel size", 1, 10, 3)
        kernel = np.ones((ksize, ksize), np.uint8)
        processed_image = cv2.erode(image, kernel, iterations=1)

    elif operation == "Dilation":
        ksize = st.slider("Kernel size", 1, 10, 3)
        kernel = np.ones((ksize, ksize), np.uint8)
        processed_image = cv2.dilate(image, kernel, iterations=1)

    elif operation == "Histogram Equalization":
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        processed_image = cv2.equalizeHist(gray)

    if processed_image is not None:
        st.subheader("Processed Image")
        if len(processed_image.shape) == 2:
            st.image(processed_image, use_column_width=True, clamp=True, channels="GRAY")
        else:
            st.image(cv2.cvtColor(processed_image, cv2.COLOR_BGR2RGB), use_column_width=True)

        # Download button
        _, buffer = cv2.imencode('.png', processed_image)
        st.download_button(
            label="Download Processed Image",
            data=buffer.tobytes(),
            file_name="processed_image.png",
            mime="image/png"
        )